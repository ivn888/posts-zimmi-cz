<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta name="author" content="Michal Zimmermann">
  <meta name="description" content="Pieces of knowledge from the world of GIS." />
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> Michal Zimmermann  &mdash; Category: SQL </title>
  <link rel="stylesheet" type="text/css" href="/posts/css/style.min.css" />
  <link href='http://fonts.googleapis.com/css?family=Roboto+Condensed:400,700' rel='stylesheet' type='text/css'>
  <script src="/posts/js/highlight.pack.js" defer></script>
  <script>
    window.onload = function() {
      var pre = document.getElementsByTagName('pre');
      for (var i = 0; i < pre.length; i += 1) {
        hljs.highlightBlock(pre[i].firstChild);
      }
    }
  </script>
</head>
<body>
    <div id="main" class="container">
        <div class="row">
            <header role="banner">
                <hgroup>
                    <h1><a href="/posts/">Michal Zimmermann</a></h1>
                    <strong>Pieces of knowledge from the world of GIS.</strong>
                </hgroup>
            </header>
            <nav role="navigation">
                <ul class="nav nav-pills main-navigation">
                    <li><a href="/posts/">Home</a></li>
                    <li><a href="/posts/categories/">Categories</a></li>
                    <li><a href="/posts/tags/">Tags</a></li>
                    <li><a href="/posts/feed.xml">RSS</a></li>
                </ul>
            </nav>
        </div>
        <div class="shadow">
            <div class="row white">
                <div id="content">
                    <div class="blog-index">
                                                                        <h1>Posts in category SQL</h1>
                                                  <section>
		<article>
	<header>
	<h2><a href="/posts/2015/postgis-rectangular-grid-creation/">Postgis Rectangular Grid Creation</a></h2>
	<small>Written on March 24, 2015
		and marked as
		<a href="/posts/tag/postgresql/">postgresql</a>, 		<a href="/posts/tag/postgis/">postgis</a>				| <a href="/posts/category/sql/">SQL</a>
		</small>
	</header>
	<section>
	<p>Creating a rectangular grid to cover a given extent with same sized cells is one of the basic GIS tasks I&#8217;ve had to solve several times so far. I used QGIS or some Python to give me a bunch of <code>INSERT</code> statements to run in PostGIS database, now I&#8217;ve finally come with a final solution.</p>

<pre><code>CREATE OR REPLACE FUNCTION cm_grid(
    blx float8, -- bottom left x coordinate
    bly float8, -- bottom left y coordinate
    trx float8, -- top right x coordinate
    try float8, -- top right y coordinate
    xsize float8, -- cell width
    ysize float8, -- cell height
    srid integer DEFAULT 5514,
    OUT col varchar,
    OUT "row" varchar,
    OUT geom geometry
) RETURNS SETOF record AS
$$
DECLARE
    width float8; -- total area width
    height float8; -- total area height
    cols integer;
    rows integer;
BEGIN
    width  := @($1 - $3); -- absolute value
    height := @($2 - $4); -- absolute value
    cols   := ceil(width / xsize);
    rows   := ceil(height / ysize);
    RETURN QUERY
        SELECT
            cast(
                lpad((i)::varchar,
                CASE WHEN
                    char_length(rows::varchar) &gt; char_length(cols::varchar)
                        THEN  char_length(rows::varchar)
                        ELSE char_length(cols::varchar)
                END,
                '0')
                AS varchar
            ) AS row,
            cast(
                lpad((j)::varchar,
                CASE WHEN
                    char_length(rows::varchar) &gt; char_length(cols::varchar)
                        THEN  char_length(rows::varchar)
                        ELSE char_length(cols::varchar)
                END,
                '0') AS varchar
            ) AS col,
            ST_SetSRID(
                ST_GeomFromText(
                    'POLYGON((' ||
                        array_to_string(
                            ARRAY[i * xsize + blx, j * ysize + bly],
                            ' '
                        ) || ',' ||
                        array_to_string(
                            ARRAY[i * xsize + blx, (j+1) * ysize + bly],
                            ' '
                        ) || ',' ||
                        array_to_string(
                            ARRAY[(i+1) * xsize + blx, (j+1) * ysize + bly],
                            ' '
                        ) || ',' ||
                        array_to_string(
                            ARRAY[(i+1) * xsize + blx, j * ysize + bly],
                            ' '
                        ) || ',' ||
                        array_to_string(
                            ARRAY[i * xsize + blx, j * ysize + bly],
                            ' '
                        ) || '
                    ))'
                )
            , srid) AS geom
        FROM
            generate_series(0, cols) AS i,
            generate_series(0, rows) AS j;
END;
$$
LANGUAGE plpgsql;
</code></pre>

<p>And you call it like this:</p>

<pre><code>CREATE TABLE grid AS
SELECT *
FROM cm_grid(-675593.69, -1057711.19, -672254.69, -1054849.19, 333.47, 333.47);
</code></pre>

<p>Few notes:</p>

<ul>
<li>it takes bounding box coordinates (bottom left, top right) for an extent,</li>
<li>followed by cell width and height,</li>
<li>and optional SRID (defaults to 5514 which is Czech national grid),</li>
<li>each cell is indexed with <code>row</code> and <code>col</code> number</li>
</ul>

<p>The messy <code>CASE</code> statement makes sure both <code>row</code> and <code>col</code> are of the same length. I used <code>array_to_string</code> for better readability. It might not be the fastest way, didn&#8217;t do any benchmarks.</p>

	</section>
</article>		<article>
	<header>
	<h2><a href="/posts/2015/postgis-buffers-intersections-differences-and-collections/">PostGIS: Buffers, Intersections, Differences And Collections</a></h2>
	<small>Written on March 19, 2015
		and marked as
		<a href="/posts/tag/postgis/">postgis</a>, 		<a href="/posts/tag/postgresql/">postgresql</a>				| <a href="/posts/category/sql/">SQL</a>
		</small>
	</header>
	<section>
	<p>Being part of <a href="http://clevermaps.cz">CleverMaps</a> means doing lot of nasty work with PostGIS. Recently, I&#8217;ve been given a following task that needed to be done for a really big project dealing with agricultural parcels:</p>

<ul>
<li>given a polygonal shapefile of agricultural parcels, create 20m wide buffers around all of them,</li>
<li>extract holes from these parcels,</li>
<li>clip buffers so they don&#8217;t overlap with other parcels,</li>
<li>get rid of overlaps between nearby parcels (e.g. dissolve them),</li>
<li>create output combined from holes and buffers,</li>
<li>the output must not contain features having more than ~1,000,000 vertices</li>
</ul>

<p>This process is going to be run ~20&times; on layers with ~40,000-70,000 polygons.</p>

<h2>Input data</h2>

<ul>
<li>polygonal layer of agricultural parcels</li>
<li>rectangular grid (7.5 &times; 7.5 km) for cutting the output</li>
</ul>

<h2>First try</h2>

<p>My initial effort was to union all the buffers and then clip them with a rectangular grid. Long story short: <strong>Don&#8217;t do that. Never. Ever. I mean it.</strong></p>

<p>It works fine until you end up with one huge multipolygon having like ~2,000,000 vertices. But then you need to split it somehow so you meet the 1,000,000 limit rule (see list above). Spatial index doesn&#8217;t help you much in such cases, so that really huge polygon is being cut by every rectangle it intersects and it takes hours and hours. It&#8217;s just a no go.</p>

<h2>The other way round</h2>

<p>Let&#8217;s put it the other way round. First, split buffers by rectangular grid, doing union on each cell separately.</p>

<h3>Import</h3>

<p>Using the swiss knife of GIS to import the data:</p>

<pre><code>export SHAPE_ENCODING="ISO-8859-1"
ogr2ogr -f PostgreSQL PG:"dbname=db user=postgres" parcels.shp -lco ENCODING=UTF-8 -t_srs "EPSG:2154"
ogr2ogr -f PostgreSQL PG:"dbname=db user=postgres" grid.shp -lco ENCODING=UTF-8 -t_srs "EPSG:2154"
</code></pre>

<h3>PostGIS processing</h3>

<p>Recently I stumbled upon a psql <code>\set</code> command. Launching several queries on the same table, it might be useful to define it&#8217;s name with <code>\set table tablename</code>:</p>

<pre><code>\set table 'parcels'
-- prepare separate table for holes (inner rings)
DROP TABLE IF EXISTS holes;
CREATE TABLE holes (
id serial,
ilot_id varchar,
wkb_geometry geometry('Polygon', 2154),
path integer);
</code></pre>

<p>I found the following query an easy way to get all the rings from geometries having more than one ring:</p>

<pre><code>INSERT INTO holes (ilot_id, wkb_geometry, path) (
SELECT id,
    (ST_DumpRings(wkb_geometry)).geom::geometry('Polygon', 2154) as wkb_geometry,
    unnest((ST_DumpRings(wkb_geometry)).path) as path
FROM :table
WHERE ST_NRings(wkb_geometry) &gt; 1
);
</code></pre>

<p>Here&#8217;s a little trick. Doing some checks I found out that some of the polygons had two rings without having any inner ring, both of them being the same. I guess this comes from some kind of human error. This query thus deletes all rings with <code>path = 0</code> (exterior rings). At the same time, it deals with that <em>invalid</em> polygons by checking their spatial relationship to parcels.</p>

<pre><code>DELETE FROM holes
    WHERE path = 0
    OR id IN (
        SELECT holes.id
        FROM holes
        JOIN :table ON
            ST_Within(
                ST_Buffer(holes.wkb_geometry,-1),
                :table.wkb_geometry
            )
        AND holes.wkb_geometry &amp;&amp; :table.wkb_geometry
);
</code></pre>

<p>To my surprise, it is possible that parcel has a hole with another parcel being in that hole. Argh. Find those and get rid of them.</p>

<pre><code>DROP TABLE IF EXISTS ints;
CREATE TABLE ints AS
    SELECT holes.*
    FROM holes
    JOIN :table ON ST_Intersects(holes.wkb_geometry, :table.wkb_geometry)
    AND ST_Relate(holes.wkb_geometry, :table.wkb_geometry, '2********');
DELETE FROM holes
WHERE id IN (SELECT id FROM ints);
</code></pre>

<p>I still need to get the difference between the hole geometry and the parcel that resides inside it - this difference is the actual hole I&#8217;m looking for.</p>

<pre><code>DROP TABLE IF EXISTS diff_ints;
CREATE TABLE diff_ints AS
    SELECT
        ints.id,
        ST_Difference(
            ints.wkb_geometry,
            ST_Collect(:table.wkb_geometry)
        ) wkb_geometry
    FROM ints, :table
    WHERE ST_Within(:table.wkb_geometry, ints.wkb_geometry)
    GROUP BY ints.wkb_geometry, ints.id;
</code></pre>

<p>And I&#8217;m done with holes. Get back to buffers.</p>

<pre><code>DROP TABLE IF EXISTS buffer;
CREATE TABLE buffer AS
    SELECT id, ST_Buffer(wkb_geometry, 20) wkb_geometry
    FROM :table;
CREATE INDEX buffer_gist_idx ON buffer USING gist(wkb_geometry);
ALTER TABLE buffer ADD PRIMARY KEY(id);
VACUUM ANALYZE buffer;
</code></pre>

<p>Combine all the parts together.</p>

<pre><code>DROP TABLE IF EXISTS diff;
CREATE TABLE diff AS
    SELECT a.id, ST_Difference(a.wkb_geometry, ST_Union(ST_MakeValid(b.wkb_geometry))) as wkb_geometry
    FROM buffer a, :table b
    WHERE ST_Intersects(a.wkb_geometry, b.wkb_geometry)
    GROUP BY a.id, a.wkb_geometry
    UNION
    SELECT id::varchar, wkb_geometry FROM holes
    UNION
    SELECT id::varchar, wkb_geometry FROM diff_ints;
CREATE INDEX diff_gist_idx ON diff USING gist(wkb_geometry);
VACUUM ANALYZE diff;
</code></pre>

<p>Collect the geometries in every cell, simplify them a little, snap them to 3 decimal numbers, make them valid and dump them to simple features. This query takes ~300,000 ms which is orders of magnitude faster than my initial attempt.</p>

<pre><code>DROP TABLE IF EXISTS uni;
CREATE TABLE uni AS
SELECT
    g.ogc_fid AS grid_id,
    (ST_Dump(
        ST_MakeValid(
            ST_SnapToGrid(
                ST_SimplifyPreserveTopology(
                    ST_CollectionExtract(
                        ST_Buffer(
                            ST_Collect(
                                ST_Intersection(a.wkb_geometry, g.wkb_geometry)
                            )
                        , 0)
                    , 3)
                , 0.1)
            , 0.001)
        )
    )).geom as wkb_geometry
FROM diff a, grid g
WHERE ST_Intersects(a.wkb_geometry, g.wkb_geometry)
GROUP BY g.ogc_fid;
</code></pre>

<p>After running the query it is reasonable to check the results. I&#8217;m only interested in polygonal geometries, <code>ST_GeometryType()</code> would tell me of any other geometry type. Invalid geometries are not allowed.</p>

<pre><code>SELECT DISTINCT ST_GeometryType(wkb_geometry) FROM uni;
SELECT COUNT(1) FROM uni WHERE NOT ST_IsValid(wkb_geometry);
</code></pre>

<p>Add primary key on serial column as a last SQL step.</p>

<pre><code>ALTER TABLE uni ADD COLUMN id serial;
ALTER TABLE uni ADD PRIMARY KEY(id);
</code></pre>

<h3>Export</h3>

<p>And spit it out as a shapefile.</p>

<pre><code>ogr2ogr -f "ESRI Shapefile" output.shp PG:"dbname=ign user=postgres" uni -s_srs "EPSG:2154" -t_srs "EPSG:2154" -lco ENCODING=UTF-8
</code></pre>

<h2>Lesson learned</h2>

<ul>
<li>More of little seems to be faster than less of bigger.</li>
<li>Never stop learning and trying different approaches.</li>
<li>Although using <code>CTE</code> might be tempting, creating separate tables for separate steps of the whole process is much more comfortable for debugging.</li>
</ul>

	</section>
</article>		<article>
	<header>
	<h2><a href="/posts/2015/postgis-case-study-vozejkmap-open-data-part-ii/">PostGIS Case Study: Vozejkmap Open Data (Part II)</a></h2>
	<small>Written on February 21, 2015
		and marked as
		<a href="/posts/tag/postgresql/">postgresql</a>, 		<a href="/posts/tag/postgis/">postgis</a>				| <a href="/posts/category/sql/">SQL</a>
		</small>
	</header>
	<section>
	<p><a href="/posts/2014/postgis-case-study-vozejkmap-open-data-part-i/">In the first part of my little case study</a> I downloaded <a href="http://vozejkmap.cz">vozejkmap.cz</a> dataset and imported it into the PostGIS database. Having spatial data safely stored the time comes to get it onto the map. Libraries used are:</p>

<ul>
<li><a href="http://leafletjs.com">Leaflet</a></li>
<li><a href="https://github.com/lvoogdt/Leaflet.awesome-markers">Leaflet.awesome-markers</a></li>
<li><a href="https://github.com/Leaflet/Leaflet.markercluster">Leaflet.markercluster</a></li>
</ul>

<p>I teach cartography visualization classes this semester and this map should serve well as an example of what can be done with online maps.</p>

<h2>Retrieving data from the PostGIS database</h2>

<p>Our goal is to build the whole map as a static HTML page without any backend logic. Thus, data needs to be extracted from the database into the format readable with Leaflet - <a href="http://geojson.org/">GeoJSON</a>.</p>

<p>That&#8217;s fairly easy with the <a href="http://www.postgresonline.com/journal/archives/267-Creating-GeoJSON-Feature-Collections-with-JSON-and-PostGIS-functions.html">postgresonline.com tutorial</a>. It took me quite a time to find out what the following query does. Splitting it into smaller chunks helped a lot.</p>

<pre><code>SELECT row_to_json(fc)
FROM (
SELECT 'FeatureCollection' AS type,
    array_to_json(array_agg(f)) AS features
    FROM (SELECT 'Feature' AS type,
        ST_AsGeoJSON(lg.geom)::json As geometry,
        row_to_json((SELECT l FROM (SELECT id, title, location_type, description, author_name, attr1, attr2, attr3) AS l
  )) AS properties
FROM vozejkmap AS lg ) AS f )  AS fc \g /path/to/file.json;
</code></pre>

<p>To get all rows with <code>type</code>, <code>geometry</code> and <code>properties</code> columns (these are the ones defined in GeoJSON specification, see the link above), run this:</p>

<pre><code>SELECT 'Feature' AS type,
            ST_AsGeoJSON(lg.geom)::json As geometry,
            row_to_json((SELECT l FROM (SELECT id, title, location_type, description, author_name, attr1, attr2, attr3) AS l
      )) AS properties
    FROM vozejkmap AS lg
</code></pre>

<p><code>array_agg()</code> squashes all the rows into an array while <code>array_to_json()</code> returns the array as JSON.</p>

<pre><code>SELECT 'FeatureCollection' AS type,
    array_to_json(array_agg(f)) AS features
    FROM (SELECT 'Feature' AS type,
        ST_AsGeoJSON(lg.geom)::json As geometry,
        row_to_json((SELECT l FROM (SELECT id, title, location_type, description, author_name, attr1, attr2, attr3) AS l
  )) AS properties
FROM vozejkmap AS lg ) AS f
</code></pre>

<p>In the last step (the whole code as shown above) <code>row_to_json</code> returns the result as JSON.</p>

<h3>Caveats</h3>

<p>If you run this code from the psql console, be sure you</p>

<ul>
<li>set <em>show only row</em> to true with <code>\t</code></li>
<li>set <em>expanded output</em> to false with <code>\x off</code></li>
</ul>

<p>If you don&#8217;t, you&#8217;ll have lots of hyphens and column names saved to the json file.</p>

<h2>Leaflet map</h2>

<p>Map JavaScript is rather simple with ~30 lines of code (not taking styles into account). Thanks to the great plugins it is easy to show ~7,600 points on the map real quick.</p>

<p>I didn&#8217;t do much customization apart from styling markers and binding popups.</p>

<p><img src="/posts/2015/postgis-case-study-vozejkmap-open-data-part-ii/map.png" title="vozejkmap.cz data map" class="img-responsive centered"></p>

<h2>What&#8217;s next</h2>

<ol>
<li><a href="http://turfjs.org">Turf</a> which means I need to think of what could be fun to do with this data</li>
<li>Layers switching</li>
<li>Map key (by extending L.Control)</li>
</ol>

<p>The code is still <a href="https://github.com/zimmicz/vozejkmap-to-postgis">available at my GitHub</a>.</p>

	</section>
</article>		<article>
	<header>
	<h2><a href="/posts/2015/using-postgresql-to-update-outdated-map-links/">Using PostgreSQL To Update Outdated Map Links</a></h2>
	<small>Written on February 16, 2015
		and marked as
		<a href="/posts/tag/postgresql/">postgresql</a>, 		<a href="/posts/tag/regex/">regex</a>				| <a href="/posts/category/sql/">SQL</a>
		</small>
	</header>
	<section>
	<p><a href="http://www.edpp.cz/pdb_mapa-povodnoveho-planu-mesta/">We&#8217;ve rolled out</a> completely new map GUI at <a href="http://edpp.cz">edpp.cz</a> built on top of <a href="http://ol3js.org">OpenLayers 3</a>. It looks great and has lots of functions both for BFU and power users. The only pitfall that came with moving away from OpenLayers 2 were remarkable differences in zoom levels between the old map and the new one.</p>

<p>Each of our maps is defined by our admins (center, zoom level, layers) at the map creation. Lots of links calling different views of map are created as well. They take form of <code>http://edpp.cz/some-map?0=0&amp;1=0...zoom=5</code>. That <code>zoom=&lt;Number&gt;</code> started causing troubles immediately after the map switch. No way my workmates would update them one by one as there were ~4,500 of them. Sounds like a task for little bit of regular expressions and some SQL updates.</p>

<pre><code>UPDATE table
    SET column = regexp_replace(column, 'zoom=\d', 'zoom=' || subquery.zoom, 'g')
    FROM (
        SELECT regexp_replace(
            substring(column from 'zoom=\d'),
            'zoom=(\d)',
            '\1',
            'g')::integer + 2 AS zoom, guid
        FROM table) AS subquery
    WHERE column ~ 'zoom=\d'
        AND table.guid = subquery.guid
</code></pre>

<p>That&#8217;s what I&#8217;ve come up with. It basically extracts the zoom level from the link, adds number two to its value and writes it back to the string.</p>

	</section>
</article>		<article>
	<header>
	<h2><a href="/posts/2014/postgis-case-study-vozejkmap-open-data-part-i/">PostGIS Case Study: VozejkMap Open Data (Part I)</a></h2>
	<small>Written on December 2, 2014
		and marked as
		<a href="/posts/tag/postgresql/">postgresql</a>, 		<a href="/posts/tag/postgis/">postgis</a>				| <a href="/posts/category/sql/">SQL</a>
		</small>
	</header>
	<section>
	<p><a href="http://www.vozejkmap.cz">VozejkMap.cz</a> is a Czech <strong>open data</strong> iniatitive that collects data about wheelchair accessible places, e.g. pubs, toilets, cafes etc. As part of being open, they offer a <a href="http://www.vozejkmap.cz/opendata/">JSON data download</a>. JSON is a great text format, not so great spatial format (leaving GeoJSON aside) though. Anyway, nothing that <a href="http://posts.zimmi.cz/tag/postgis/">PostGIS</a> wouldn&#8217;t be able to take care of.</p>

<h3>Let&#8217;s get some data</h3>

<p>Using curl or wget, let&#8217;s download the JSON file:</p>

<pre><code>wget -O /tmp/locations.json http://www.vozejkmap.cz/opendata/locations.json
</code></pre>

<p>We need to split them into rows to load each point into one row:</p>

<pre><code>sed -i 's/\},{/\n},{/g' /tmp/locations.json
</code></pre>

<p>If you peep into the file, you&#8217;ll see lots of unicode characters we don&#8217;t want to have in our pretty little table. Here&#8217;s how we get rid of them:</p>

<pre><code>echo -en "$(cat /tmp/locations.json)"
</code></pre>

<h3>Let&#8217;s load the data</h3>

<p>Let&#8217;s just be nice and leave the public schema clean.</p>

<pre><code>CREATE SCHEMA vozejkmap;
SET search_path=vozejkmap, public;
</code></pre>

<p>Load the data:</p>

<pre><code>CREATE TABLE vozejkmap_raw(id SERIAL PRIMARY KEY, raw text);
COPY vozejkmap_raw(raw) FROM '/tmp/locations.json' DELIMITERS '#' ESCAPE '\' CSV;
</code></pre>

<p>A few notes:</p>

<ol>
<li>I&#8217;m using <code>/tmp</code> folder to avoid any permission-denied issues when opening the file from <code>psql</code>.</li>
<li>By setting <code>DELIMITERS</code> to <code>#</code> we tell PostgreSQL to load whole data into one column, because it is safe to assume there is no such character in our data.</li>
<li><code>ESCAPE</code> needs to be set because there is one trailing quote in the dataset.</li>
</ol>

<h3>Let&#8217;s get dirty with spatial data</h3>

<p>Great, now what? We loaded all the data into one column. That is not very useful, is it? How about splitting them into separate columns with this query? Shall we call it a <code>split_part</code> hell?</p>

<pre><code>CREATE TABLE vozejkmap AS
SELECT
    id,
    trim(
        split_part(
            split_part(
                raw, 'title:', 2
            ),
            ',location_type:', 1
        )
    ) AS title,

    trim(
        split_part(
            split_part(
                raw, 'location_type:', 2
            ),
            ',description:', 1
        )
    )::integer AS location_type,

    trim(
        split_part(
            split_part(
                raw, 'description:', 2
            ),
            ',lat:', 1
        )
    ) AS description,

    cast( trim(
        split_part(
            split_part(
                raw, 'lat:', 2
            ),
            ',lng:', 1
        )
    ) AS double precision) AS lat,

    cast( trim(
        split_part(
            split_part(
                raw, 'lng:', 2
            ),
            ',attr1:', 1
        )
    )  AS double precision) AS lng,

    trim(
        split_part(
            split_part(
                raw, 'attr1:', 2
            ),
            ',attr2:', 1
        )
    )::integer AS attr1,

    trim(
        split_part(
            split_part(
                raw, 'attr2:', 2
            ),
            ',attr3:', 1
        )
    ) AS attr2,

    trim(
        split_part(
            split_part(
                raw, 'attr3:', 2
            ),
            ',author_name:', 1
        )
    ) AS attr3,

    trim(
        split_part(
            split_part(
                raw, 'author_name:', 2
            ),
            ',}:', 1
        )
    ) AS author_name

FROM vozejkmap_raw;
</code></pre>

<p>It just splits the JSON data and creates table out of it according to the <a href="http://www.vozejkmap.cz/opendata/">VozejkMap.cz data specification</a>. Before going on we should create a table with location types to join their numeric codes to real names:</p>

<pre><code>CREATE TABLE location_type (
    id integer PRIMARY KEY,
    description varchar(255)
);

INSERT INTO location_type VALUES(1, 'Kultura');
INSERT INTO location_type VALUES(2, 'Sport');
INSERT INTO location_type VALUES(3, 'Instituce');
INSERT INTO location_type VALUES(4, 'Jídlo a pití');
INSERT INTO location_type VALUES(5, 'Ubytování');
INSERT INTO location_type VALUES(6, 'Lékaři, lékárny');
INSERT INTO location_type VALUES(7, 'Jiné');
INSERT INTO location_type VALUES(8, 'Doprava');
INSERT INTO location_type VALUES(9, 'Veřejné WC');
INSERT INTO location_type VALUES(10, 'Benzínka');
INSERT INTO location_type VALUES(11, 'Obchod');
INSERT INTO location_type VALUES(12, 'Banka, bankomat');
INSERT INTO location_type VALUES(13, 'Parkoviště');
INSERT INTO location_type VALUES(14, 'Prodejní a servisní místa Škoda Auto');
</code></pre>

<p>Let&#8217;s build some geometry column, constraints and indexes. And don&#8217;t forget to get rid of all the mess (the <code>vozejkmap_raw</code> table).</p>

<pre><code>DROP TABLE vozejkmap_raw;
ALTER TABLE vozejkmap ADD PRIMARY KEY(id);
-- 4326 geometry is not very useful for measurements, I might get to that next time
ALTER TABLE vozejkmap ADD COLUMN geom geometry(point, 4326);
ALTER TABLE vozejkmap ADD CONSTRAINT loctype_fk FOREIGN KEY(location_type); REFERENCES location_type(id);

UPDATE vozejkmap SET geom = ST_SetSRID(ST_MakePoint(lng, lat), 4326);
</code></pre>

<p><strong>And here we are, ready to use our spatial data!</strong></p>

<p>Feel free to <a href="https://github.com/zimmicz/vozejkmap-to-postgis">grab the code</a> at GitHub.</p>

	</section>
</article>		<article>
	<header>
	<h2><a href="/posts/2014/postgis-spatial-indexing-with-st-intersects/">PostGIS Spatial Indexing With ST_Intersects</a></h2>
	<small>Written on November 23, 2014
		and marked as
		<a href="/posts/tag/postgis/">postgis</a>				| <a href="/posts/category/sql/">SQL</a>
		</small>
	</header>
	<section>
	<p><a href="http://postgis.net/docs/ST_Intersects.html">PostGIS docs</a> clearly states that:</p>

<blockquote>
  <p>This function call will automatically include a bounding box comparison that will make use of any indexes that are available on the geometries.</p>
</blockquote>

<p>That means (or at least I think so) that you shouldn&#8217;t bother with using <a href="http://postgis.net/docs/reference.html#Operators">operators</a> before calling this function.</p>

<p><a href="http://slides.com/michalzimmermann">I was preparing</a> my second lecture on PostGIS and I was experimenting a bit and came up with an interesting thing on this matter:</p>

<p>Let&#8217;s have two SQL relations, <code>roads</code> and <code>regions</code>. I would like to retrieve every road that intersects a certain region. Spatial indexes were built beforehand on both tables.</p>

<p>First try:</p>

<pre><code>EXPLAIN ANALYZE SELECT roads.* FROM roads
JOIN regions ON ST_Intersects(roads.geom, regions.geom)
WHERE regions."NAZEV" = 'Jihomoravský';`
</code></pre>

<p>And here comes the result:</p>

<pre><code>Nested Loop  (cost=4.85..324.26 rows=249 width=214) (actual time=45.102..5101.472 rows=74253 loops=1)
-&gt;  Seq Scan on regions  (cost=0.00..12.62 rows=1 width=32) (actual time=0.015..0.018 rows=1 loops=1)
     Filter: (("NAZEV")::text = 'Jihomoravský'::text)
     Rows Removed by Filter: 13
-&gt;  Bitmap Heap Scan on roads  (cost=4.85..311.38 rows=25 width=214) (actual time=45.079..4931.495 rows=74253 loops=1)
     Recheck Cond: (geom &amp;&amp; regions.geom)
     Rows Removed by Index Recheck: 154841
     Filter: _st_intersects(geom, regions.geom)
     Rows Removed by Filter: 71212
     -&gt;  Bitmap Index Scan on roads_idx  (cost=0.00..4.85 rows=75 width=0) (actual time=40.142..40.142 rows=145465 loops=1)
           Index Cond: (geom &amp;&amp; regions.geom)
Total runtime: 5181.459 ms
</code></pre>

<p>I was pretty satisfied with the result, I kept digging deeper though.</p>

<p>Second try:</p>

<pre><code>EXPLAIN ANALYZE SELECT roads.* FROM roads
JOIN regions ON roads.geom &amp;&amp; regions.geom
WHERE regions."NAZEV" = 'Jihomoravský' AND ST_Intersects(roads.geom, regions.geom);
</code></pre>

<p>And the result:</p>

<pre><code>Nested Loop  (cost=0.29..21.19 rows=1 width=214) (actual time=3.041..3850.302 rows=74253 loops=1)
-&gt;  Seq Scan on regions  (cost=0.00..12.62 rows=1 width=32) (actual time=0.021..0.024 rows=1 loops=1)
     Filter: (("NAZEV")::text = 'Jihomoravský'::text)
     Rows Removed by Filter: 13
-&gt;  Index Scan using roads_idx on roads  (cost=0.29..8.55 rows=1 width=214) (actual time=2.938..3681.432 rows=74253 loops=1)
     Index Cond: ((geom &amp;&amp; regions.geom) AND (geom &amp;&amp; regions.geom))
     Filter: _st_intersects(geom, regions.geom)
     Rows Removed by Filter: 71212
Total runtime: 3930.270 ms
</code></pre>

<p>Now there&#8217;s a significant difference between total runtimes of both queries and - more important - also a difference between their query plans. The latter is like <strong>20 % faster</strong>.</p>

<p>I&#8217;m puzzled about this behavior and would appreciate any thoughts on this. Reach me at <a href="http://twitter.com/zimmicz">Twitter</a>, <a href="https://www.linkedin.com/pub/michal-zimmermann/29/8/b30">LinkedIn</a> or e-mail (zimmicz[at]gmail.com).</p>

	</section>
</article></section>

                                          </div>
                </div>
            </div>
            <div class="row white">
                <footer role="contentinfo">
                                          
                                                              <p>Written by <a href="http://www.zimmi.cz">Michal Zimmermann</a>. Baked with <em><a href="http://bolt80.com/piecrust/">PieCrust</a> 1.2.0</em>.</p>
                </footer>
            </div>
        </div>
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-43432739-2', 'auto');
      ga('send', 'pageview');
    </script>
</body>
</html>